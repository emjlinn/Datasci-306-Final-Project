---
title: "Stats 306, Homework 3"
author: "Your name, Your uniqname"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
```

## Question 1 (8 points)

We will revisit the crime data we explored visually in the last homework
```{r}
crime <- read_csv("./data/RMS_Crime_Incidents.csv.gz")
```

If you want to see the source of this data: [City of Detroit crime event data](https://data.detroitmi.gov/datasets/detroitmi::rms-crime-incidents/explore).

Description from the City of Detroit Open Data Portal:

> This data reflects reported criminal offenses that have occurred in the City of Detroit. Offense data was extracted from the Detroit Police Department's records management system.
>
> This data reflects reported criminal offenses that have occurred in the City of Detroit. Offense data was extracted from the Detroit Police Department's records management system. This data set contains the most recent data available and is updated anytime DPD sends official crime records contributing to the Michigan Incident Crime Reporting (MICR) or the National Incident Based Reporting systems (reflected by the IBR Date field). It should be noted that some incidents involve the commission of multiple offenses, such as a domestic assault where property was also vandalized. Accordingly, the data describe all offenses associated with all reported incidents.


### When do crimes occur? (2 points)

The `cut` function is useful for breaking up a quantitative variable into discrete categories. Here is an example:

```{r}
x <- c(2, -1, 0.5, 10, 3, 4, -0.25, 6)
cut(x, breaks = c(-Inf, 0, 5, Inf))
```

The notation `(a, b]` means that the interval is defined by $a < x \le b$ (i.e., a half closed interval).

We can also include labels:
```{r}
cut(x, breaks = c(-Inf, 0, 5, Inf), labels = c("Small", "Medium", "Large"))
```

Note, you can give the same label twice to get two cuts to be the same group.
```{r}
cut(x, breaks = c(-Inf, 0, 5, Inf), labels = c("A", "B", "A"))
```

Using the `cut` function and `mutate`, make a new column that breaks the day into the following periods:

* Work Hours (9am to 5pm)
* Non-Work Hours (6am to 9am and 5pm to 8pm)
* Night (8pm to 6pm)

(Hints: `hour_of_day` is on a 24 clock. To capture all the observations, make the first `breaks` value strictly less than 0).
We suggest writing a helper function to do the cut.

Using `group_by` and `summarize`, find the most common period of the day for a crime to occur. (hint: recall the `n()` function).

#### Solution

```{r}
# first, let's write a helper function to do the cutting
hour_to_period <- function(x){
  cut(x, breaks = c(-Inf, 6, 9, 17, 20, 24), labels = c("Night", "Non-Work", "Work", "Non-Work", "Night"))
}

# now test it on some examples: (should be N, N, E, L, N, N)
hour_to_period(c(0, 5, 10, 18, 23, 24))

# now creating the new column, grouping, and counting

mutate(crime, period = hour_to_period(hour_of_day)) |>
  group_by(period) |>
  summarize(n())
```

Here we see that Non-Work is the least common, with Night the most common category.

### Crime trend (2 points)

First find the top three neighborhoods with the most crime. You can get this count by grouping on `neighborhood` and mutating a column to find total count.

Hint: You can use the `n()` function in summarize; for e.g., `mpg |> group_by(manufacturer) |> summarize(total = n())` summarizes the total record count for each group

Then filter the crime data to select only the top three crime neighborhood and also only those crimes that occurred between 2016 and 2022 and then group by `neighborhood` 
and then by `year`, and then get the crime count for each filtered year.

Then plot a line chart to show the trend of crimes over the years for these three top crime neighborhood. Show all the lines in the same figure.

#### Solution

```{r}

crime |> group_by(neighborhood) |> summarize(total = n()) |> arrange(-total) |> select(neighborhood, total) |> head(3) -> crime_subset

# Warrendale, Downtown, and Franklin Park
filter(crime, neighborhood %in% crime_subset$neighborhood, year %in% c(2016:2023)) |>
  group_by(neighborhood, year) |> mutate(total = n()) |> 
  select(neighborhood, total, year) |> 
  ggplot(aes(x = year, y = total, color = neighborhood)) + geom_line()

```



### Finding `crimes_of_interest` Areas (2 points)

Use `filter` to create a data frame that only includes events with `offense_category` that are in the vector `crimes_of_interest`. 

We also want to create a scatter plot of the number of crimes of interest that occur at a given latitude and longitude. To accomplish this, we will create two new variables, `new_lat` and `new_long` that round the `latitude` and `longitude` variables to three decimal places. We will then use `group_by` and  `summarise` to count the total number of interested crimes at each latitude and longitude.

Afterward, we will use a scatter plot to plot the `new_lat`, and `new_long`, with the counts as the color. Make sure to use a color gradient to delineate high crime count to low crime count.

```{r}
crimes_of_interest <- c("AGGRAVATED ASSAULT", "ARSON", "ASSAULT", "HOMICIDE", 
                        "JUSTIFIABLE HOMICIDE", "KIDNAPPING", "SEX OFFENSES", 
                        "SEXUAL ASSAULT", "WEAPONS OFFENSES")
```

#### Solution

```{r}
crime |>
  filter(offense_category %in% crimes_of_interest) |>
  mutate(new_lat = round(latitude, digits = 3), 
         new_long = round(longitude, digits = 3)) |>
  select(new_lat, new_long) |>
  group_by(new_lat, new_long) |>
  summarise(count = n()) |>
  ggplot(aes(y = new_lat, x = new_long, color = count)) +
  geom_point() +
  scale_color_gradient(low = "blue", high = "red") + 
  labs(
    x = "Longitude",
    y = "Latitude",
    color = "Crime Count"
  )
```

### Normalizing Incident Time of All Crimes Based on Offense Category (2 points)
Use `group_by()` on offense_category and find the count of each offense category and then normalize this total by adding a new column that shows normalized count values. This new column should have values between 0 and 1 only for each offense category.

#### Solution

```{r}

crime |>
  group_by(offense_category) |>
  summarize(total = n()) |> mutate (normalized_total = (total - min(total, rm.na = T)) / (max(total, rm.na = T) - min(total, rm.na = T))) |> 
  select(offense_category, total, normalized_total) -> d

d$normalized_total |> range()
         
```

## Question 2: Air Quality (2 points)

In this problem, we will explore Air Quality dataset, which includes daily air quality measurements in New York, May to September 1973. It is a build-in dataset in R so we can directly load the dataset. Use help or ? to get the description of dataset.

```{r}
airquality %>% head()
```

Generate a line plot with dots reflecting the variation of monthly temperature and ozone level using mean value. What can you learn from the plot? Provide a brief description over the relationship between temperature and ozone. Your plot should look like the chart given



<img src='airquality.png' />


#### SOLUTION

```{r}

colors <- c("avg_temp" = "red", "avg_ozone" = "blue")
airquality %>%
  group_by(Month) %>%
  summarize(avg_temp = mean(Temp, na.rm = TRUE),
            avg_ozone = mean(Ozone, na.rm = TRUE)) %>%
  ggplot() +
    geom_line(aes(x = Month, y = avg_temp, color = "avg_temp")) +
    geom_point(aes(x = Month, y = avg_temp, color = "avg_temp")) +
    geom_line(aes(x = Month, y = avg_ozone, color = "avg_ozone")) +
    geom_point(aes(x = Month, y = avg_ozone, color = "avg_ozone")) +
    labs(x = "Month", y = "Average Values", color = "Feature") +
    scale_color_manual(values = colors) +
    ggtitle("Monthly Temperature and Ozone value Line Plot") +
    theme_bw()

```